name: BMKG Earthquake Monitor

on:
  workflow_dispatch: # Manual trigger only

env:
  GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
  DISCORD_WEBHOOK_BMKG: ${{ secrets.DISCORD_WEBHOOK_BMKG }}

permissions:
  contents: write

jobs:
  earthquake-monitor:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ github.token }}

    - name: Setup Python environment
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        pip install requests

    - name: Fetch and process earthquake data
      run: |
        python -c "
        import requests
        import json
        import os
        import sys
        from datetime import datetime, timezone
        import time

        # Configuration
        BMKG_API_URL = 'https://api.siputzx.my.id/api/info/bmkg'
        GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent'
        DISCORD_WEBHOOK_URL = os.getenv('DISCORD_WEBHOOK_BMKG')
        GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
        
        # File to store last sent earthquake data
        LAST_EARTHQUAKE_FILE = 'last_earthquake.json'
        
        def fetch_bmkg_data():
            try:
                headers = {'accept': '*/*'}
                response = requests.get(BMKG_API_URL, headers=headers, timeout=30)
                response.raise_for_status()
                return response.json()
            except Exception as e:
                print(f'Error fetching BMKG data: {e}')
                return None
        
        def load_last_earthquake():
            try:
                if os.path.exists(LAST_EARTHQUAKE_FILE):
                    with open(LAST_EARTHQUAKE_FILE, 'r') as f:
                        return json.load(f)
                return None
            except Exception as e:
                print(f'Error loading last earthquake data: {e}')
                return None
        
        def save_last_earthquake(earthquake_data):
            try:
                with open(LAST_EARTHQUAKE_FILE, 'w') as f:
                    json.dump(earthquake_data, f, indent=2)
                print(f'Saved last earthquake: {earthquake_data.get(\"DateTime\", \"Unknown\")}')
            except Exception as e:
                print(f'Error saving last earthquake data: {e}')
        
        def generate_earthquake_message(earthquake_data):
            try:
                # Prepare earthquake information for AI
                earthquake_info = f'''
                Latest BMKG Earthquake Data:
                - Date: {earthquake_data.get('Tanggal', 'N/A')}
                - Time: {earthquake_data.get('Jam', 'N/A')}
                - Magnitude: {earthquake_data.get('Magnitude', 'N/A')}
                - Depth: {earthquake_data.get('Kedalaman', 'N/A')}
                - Coordinates: {earthquake_data.get('Lintang', 'N/A')}, {earthquake_data.get('Bujur', 'N/A')}
                - Region: {earthquake_data.get('Wilayah', 'N/A')}
                - Potential: {earthquake_data.get('Potensi', 'N/A')}
                - Felt: {earthquake_data.get('Dirasakan', 'No reports')}
                '''
                
                # Generate AI response
                prompt = f'''
                Create an informative and easy-to-understand earthquake information message based on the following BMKG data:
                
                {earthquake_info}
                
                Message format requirements:
                1. Create an attention-grabbing but professional title
                2. Explain earthquake details in clear, natural English
                3. Include clear location information  
                4. Add context about earthquake significance and monitoring status
                5. Use natural, conversational English tone
                6. Don't use excessive emojis, just 1-2 relevant ones
                7. Maximum 300 characters for main summary
                8. Focus on public safety and informational aspects
                
                Provide response in JSON format:
                {{
                  \"title\": \"Professional earthquake alert title\",
                  \"message\": \"Clear, informative earthquake description with context\",
                  \"severity_emoji\": \"Appropriate severity emoji\",
                  \"location_focus\": \"Main affected area\"
                }}
                '''
                
                headers = {
                    'Content-Type': 'application/json',
                }
                
                data = {
                    'contents': [{
                        'parts': [{
                            'text': prompt
                        }]
                    }],
                    'generationConfig': {
                        'temperature': 0.7,
                        'topK': 40,
                        'topP': 0.95,
                        'maxOutputTokens': 1000,
                    }
                }
                
                response = requests.post(
                    f'{GEMINI_API_URL}?key={GEMINI_API_KEY}',
                    headers=headers,
                    json=data,
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if 'candidates' in result and len(result['candidates']) > 0:
                        content = result['candidates'][0]['content']['parts'][0]['text']
                        
                        # Extract JSON from response
                        try:
                            # Find JSON content
                            start_idx = content.find('{')
                            end_idx = content.rfind('}') + 1
                            if start_idx != -1 and end_idx > start_idx:
                                json_content = content[start_idx:end_idx]
                                ai_response = json.loads(json_content)
                                return ai_response
                        except json.JSONDecodeError:
                            pass
                        
                        # Fallback: use raw content
                        return {
                            'title': 'BMKG Earthquake Info',
                            'message': content[:280],
                            'severity_emoji': 'üåç',
                            'location_focus': earthquake_data.get('Wilayah', 'Indonesia')
                        }
                else:
                    print(f'AI API Error: {response.status_code} - {response.text}')
                    return None
            except Exception as e:
                print(f'Error generating AI message: {e}')
                return None
        
        def get_shakemap_url(earthquake_data):
            try:
                # Get shake map filename from earthquake data
                shakemap_filename = earthquake_data.get('Shakemap', '')
                
                if shakemap_filename:
                    # Try different BMKG shake map URL patterns with the actual filename
                    possible_urls = [
                        f'https://repogempa.bmkg.go.id/ALTE320/img/{shakemap_filename}',
                        f'https://repogempa.bmkg.go.id/shakemap/{shakemap_filename}',
                        f'https://www.bmkg.go.id/gempabumi/{shakemap_filename}',
                        f'https://repogempa.bmkg.go.id/repo/shakemap/{shakemap_filename}',
                        f'https://www.bmkg.go.id/images/shakemap/{shakemap_filename}',
                        f'https://geonet.bmkg.go.id/shakemap/{shakemap_filename}',
                        f'https://bmkg.go.id/gempabumi/shakemap/{shakemap_filename}',
                        f'https://data.bmkg.go.id/shakemap/{shakemap_filename}'
                    ]
                    
                    print(f'Trying to find shakemap for: {shakemap_filename}')
                    
                    # Try to validate URLs (basic check with shorter timeout)
                    for i, url in enumerate(possible_urls):
                        try:
                            print(f'Testing URL {i+1}/{len(possible_urls)}: {url}')
                            # Quick HEAD request to check if URL exists
                            response = requests.head(url, timeout=3, allow_redirects=True)
                            if response.status_code == 200:
                                print(f'‚úÖ Found valid shake map URL: {url}')
                                return url
                            else:
                                print(f'‚ùå Status {response.status_code}')
                        except Exception as e:
                            print(f'‚ùå Error: {e}')
                            continue
                    
                    # If no valid URL found, try the first pattern anyway (might work in Discord)
                    print(f'‚ö†Ô∏è No accessible URLs found, using first pattern: {possible_urls[0]}')
                    return possible_urls[0]
                
                # Fallback to default image
                print('No shakemap filename found, using default image')
                return 'https://files.catbox.moe/219caw.jpg'
                
            except Exception as e:
                print(f'Error getting shake map URL: {e}')
                return 'https://files.catbox.moe/219caw.jpg'
        
        def get_severity_color(magnitude):
            try:
                mag = float(magnitude)
                if mag >= 7.0:
                    return 0xFF0000  # Red - Very dangerous
                elif mag >= 6.0:
                    return 0xFF6600  # Orange - Dangerous  
                elif mag >= 5.0:
                    return 0xFFCC00  # Yellow - Moderate
                elif mag >= 4.0:
                    return 0x00CCFF  # Light blue - Minor
                else:
                    return 0x00FF00  # Green - Very minor
            except:
                return 0x808080  # Gray - Unknown
        
        def send_discord_notification(earthquake_data, ai_message):
            try:
                if not DISCORD_WEBHOOK_URL:
                    print('Discord webhook URL not configured')
                    return False
                
                # Prepare embed
                magnitude = earthquake_data.get('Magnitude', 'N/A')
                color = get_severity_color(magnitude)
                shakemap_url = get_shakemap_url(earthquake_data)
                
                # Check if we have a real shakemap or default image
                has_real_shakemap = earthquake_data.get('Shakemap', '') and shakemap_url != 'https://files.catbox.moe/219caw.jpg'
                
                # Determine thumbnail based on magnitude
                if float(magnitude) >= 6.0:
                    thumbnail_url = 'https://em-content.zobj.net/source/apple/391/red-circle_1f534.png'
                elif float(magnitude) >= 5.0:
                    thumbnail_url = 'https://em-content.zobj.net/source/apple/391/orange-circle_1f7e0.png'
                elif float(magnitude) >= 4.0:
                    thumbnail_url = 'https://em-content.zobj.net/source/apple/391/yellow-circle_1f7e1.png'
                else:
                    thumbnail_url = 'https://em-content.zobj.net/source/apple/391/green-circle_1f7e2.png'
                
                embed = {
                    'title': f'{ai_message.get(\"severity_emoji\", \"üåç\")} {ai_message.get(\"title\", \"BMKG Earthquake Info\")}',
                    'description': ai_message.get('message', 'Latest earthquake data from BMKG'),
                    'color': color,
                    'thumbnail': {
                        'url': thumbnail_url
                    },
                    'fields': [
                        {
                            'name': 'üìÖ Time',
                            'value': f'{earthquake_data.get(\"Tanggal\", \"N/A\")} - {earthquake_data.get(\"Jam\", \"N/A\")}',
                            'inline': True
                        },
                        {
                            'name': 'üìä Magnitude',
                            'value': f'{magnitude} SR',
                            'inline': True
                        },
                        {
                            'name': 'üìè Depth',
                            'value': earthquake_data.get('Kedalaman', 'N/A'),
                            'inline': True
                        },
                        {
                            'name': 'üìç Location',
                            'value': earthquake_data.get('Wilayah', 'N/A'),
                            'inline': False
                        },
                        {
                            'name': '‚ö†Ô∏è Status',
                            'value': 'Earthquake reported to public for monitoring' if earthquake_data.get('Potensi', '').lower().find('dirasakan') != -1 else earthquake_data.get('Potensi', 'No tsunami threat reported'),
                            'inline': False
                        }
                    ],
                    'footer': {
                        'text': f'BMKG Indonesia ‚Ä¢ Monitoring Active ‚Ä¢ {datetime.now(timezone.utc).strftime(\"%Y-%m-%d %H:%M:%S UTC\")}',
                        'icon_url': 'https://files.catbox.moe/npfh4e.jpg'
                    }
                }
                
                # Add 'Felt' field if available
                if earthquake_data.get('Dirasakan'):
                    felt_info = earthquake_data.get('Dirasakan')
                    # Convert MMI scale info to English if needed
                    if 'II-III' in felt_info:
                        felt_description = f'Light shaking (MMI II-III) reported in {felt_info.replace(\"II-III \", \"\")}'
                    else:
                        felt_description = f'Reported felt: {felt_info}'
                    
                    embed['fields'].append({
                        'name': 'üë• Public Reports',
                        'value': felt_description,
                        'inline': False
                    })
                
                # Add shakemap info if available
                if earthquake_data.get('Shakemap'):
                    if has_real_shakemap:
                        embed['image'] = {'url': shakemap_url}
                        embed['fields'].append({
                            'name': 'üó∫Ô∏è Intensity Map',
                            'value': 'Shake intensity visualization available below',
                            'inline': False
                        })
                    else:
                        embed['fields'].append({
                            'name': 'üó∫Ô∏è Intensity Map',
                            'value': f'Map file: {earthquake_data.get(\"Shakemap\")} (may not be publicly accessible yet)',
                            'inline': False
                        })
                
                payload = {
                    'username': 'Skye Earthquake Monitor',
                    'embeds': [embed]
                }
                
                response = requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=30)
                response.raise_for_status()
                print(f'Discord notification sent successfully')
                return True
                
            except Exception as e:
                print(f'Error sending Discord notification: {e}')
                return False
        
        def main():
            print('Starting BMKG earthquake monitor...')
            
            # Fetch latest earthquake data
            bmkg_data = fetch_bmkg_data()
            if not bmkg_data or not bmkg_data.get('status'):
                print('Failed to fetch BMKG data or invalid response')
                sys.exit(1)
            
            # Get latest earthquake from auto data
            latest_earthquake = bmkg_data.get('data', {}).get('auto', {}).get('Infogempa', {}).get('gempa')
            
            if not latest_earthquake:
                print('No earthquake data found in auto section')
                sys.exit(1)
            
            print(f'Latest earthquake: {latest_earthquake.get(\"DateTime\", \"Unknown\")} - Magnitude {latest_earthquake.get(\"Magnitude\", \"N/A\")}')
            
            # Load last sent earthquake
            last_earthquake = load_last_earthquake()
            
            # Check if this is a new earthquake
            if last_earthquake and last_earthquake.get('DateTime') == latest_earthquake.get('DateTime'):
                print('No new earthquake data - skipping notification')
                sys.exit(0)
            
            # Generate AI message
            print('Generating AI message for earthquake...')
            ai_message = generate_earthquake_message(latest_earthquake)
            
            if not ai_message:
                print('Failed to generate AI message')
                sys.exit(1)
            
            # Send Discord notification
            print('Sending Discord notification...')
            if send_discord_notification(latest_earthquake, ai_message):
                # Save this earthquake as the last sent
                save_last_earthquake(latest_earthquake)
                print('Earthquake notification completed successfully')
            else:
                print('Failed to send Discord notification')
                sys.exit(1)
        
        if __name__ == '__main__':
            main()
        "

    - name: Commit last earthquake data if changed
      run: |
        if [ -f "last_earthquake.json" ]; then
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add last_earthquake.json
          git diff --staged --quiet || git commit -m "Update last earthquake data [skip ci]"
          git push
        fi
